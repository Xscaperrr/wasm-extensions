// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NODEINFO_WASM_COMMON_H_
#define FLATBUFFERS_GENERATED_NODEINFO_WASM_COMMON_H_

#include "flatbuffers/flatbuffers.h"

namespace Wasm {
namespace Common {

struct KeyVal;
struct KeyValBuilder;

struct FlatNode;
struct FlatNodeBuilder;

struct KeyVal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef KeyValBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  bool KeyCompareLessThan(const KeyVal *o) const {
    return *key() < *o->key();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(key()->c_str(), val);
  }
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
};

struct KeyValBuilder {
  typedef KeyVal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(KeyVal::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(KeyVal::VT_VALUE, value);
  }
  explicit KeyValBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<KeyVal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<KeyVal>(end);
    fbb_.Required(o, KeyVal::VT_KEY);
    return o;
  }
};

inline flatbuffers::Offset<KeyVal> CreateKeyVal(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  KeyValBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<KeyVal> CreateKeyValDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return Wasm::Common::CreateKeyVal(
      _fbb,
      key__,
      value__);
}

struct FlatNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlatNodeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_NAMESPACE_ = 6,
    VT_LABELS = 8,
    VT_OWNER = 10,
    VT_WORKLOAD_NAME = 12,
    VT_PLATFORM_METADATA = 14,
    VT_ISTIO_VERSION = 16,
    VT_MESH_ID = 18,
    VT_APP_CONTAINERS = 20,
    VT_CLUSTER_ID = 22,
    VT_INSTANCE_IPS = 24
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *namespace_() const {
    return GetPointer<const flatbuffers::String *>(VT_NAMESPACE_);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Wasm::Common::KeyVal>> *labels() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Wasm::Common::KeyVal>> *>(VT_LABELS);
  }
  const flatbuffers::String *owner() const {
    return GetPointer<const flatbuffers::String *>(VT_OWNER);
  }
  const flatbuffers::String *workload_name() const {
    return GetPointer<const flatbuffers::String *>(VT_WORKLOAD_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Wasm::Common::KeyVal>> *platform_metadata() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Wasm::Common::KeyVal>> *>(VT_PLATFORM_METADATA);
  }
  const flatbuffers::String *istio_version() const {
    return GetPointer<const flatbuffers::String *>(VT_ISTIO_VERSION);
  }
  const flatbuffers::String *mesh_id() const {
    return GetPointer<const flatbuffers::String *>(VT_MESH_ID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *app_containers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_APP_CONTAINERS);
  }
  const flatbuffers::String *cluster_id() const {
    return GetPointer<const flatbuffers::String *>(VT_CLUSTER_ID);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *instance_ips() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_INSTANCE_IPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_NAMESPACE_) &&
           verifier.VerifyString(namespace_()) &&
           VerifyOffset(verifier, VT_LABELS) &&
           verifier.VerifyVector(labels()) &&
           verifier.VerifyVectorOfTables(labels()) &&
           VerifyOffset(verifier, VT_OWNER) &&
           verifier.VerifyString(owner()) &&
           VerifyOffset(verifier, VT_WORKLOAD_NAME) &&
           verifier.VerifyString(workload_name()) &&
           VerifyOffset(verifier, VT_PLATFORM_METADATA) &&
           verifier.VerifyVector(platform_metadata()) &&
           verifier.VerifyVectorOfTables(platform_metadata()) &&
           VerifyOffset(verifier, VT_ISTIO_VERSION) &&
           verifier.VerifyString(istio_version()) &&
           VerifyOffset(verifier, VT_MESH_ID) &&
           verifier.VerifyString(mesh_id()) &&
           VerifyOffset(verifier, VT_APP_CONTAINERS) &&
           verifier.VerifyVector(app_containers()) &&
           verifier.VerifyVectorOfStrings(app_containers()) &&
           VerifyOffset(verifier, VT_CLUSTER_ID) &&
           verifier.VerifyString(cluster_id()) &&
           VerifyOffset(verifier, VT_INSTANCE_IPS) &&
           verifier.VerifyVector(instance_ips()) &&
           verifier.VerifyVectorOfStrings(instance_ips()) &&
           verifier.EndTable();
  }
};

struct FlatNodeBuilder {
  typedef FlatNode Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(FlatNode::VT_NAME, name);
  }
  void add_namespace_(flatbuffers::Offset<flatbuffers::String> namespace_) {
    fbb_.AddOffset(FlatNode::VT_NAMESPACE_, namespace_);
  }
  void add_labels(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Wasm::Common::KeyVal>>> labels) {
    fbb_.AddOffset(FlatNode::VT_LABELS, labels);
  }
  void add_owner(flatbuffers::Offset<flatbuffers::String> owner) {
    fbb_.AddOffset(FlatNode::VT_OWNER, owner);
  }
  void add_workload_name(flatbuffers::Offset<flatbuffers::String> workload_name) {
    fbb_.AddOffset(FlatNode::VT_WORKLOAD_NAME, workload_name);
  }
  void add_platform_metadata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Wasm::Common::KeyVal>>> platform_metadata) {
    fbb_.AddOffset(FlatNode::VT_PLATFORM_METADATA, platform_metadata);
  }
  void add_istio_version(flatbuffers::Offset<flatbuffers::String> istio_version) {
    fbb_.AddOffset(FlatNode::VT_ISTIO_VERSION, istio_version);
  }
  void add_mesh_id(flatbuffers::Offset<flatbuffers::String> mesh_id) {
    fbb_.AddOffset(FlatNode::VT_MESH_ID, mesh_id);
  }
  void add_app_containers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> app_containers) {
    fbb_.AddOffset(FlatNode::VT_APP_CONTAINERS, app_containers);
  }
  void add_cluster_id(flatbuffers::Offset<flatbuffers::String> cluster_id) {
    fbb_.AddOffset(FlatNode::VT_CLUSTER_ID, cluster_id);
  }
  void add_instance_ips(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> instance_ips) {
    fbb_.AddOffset(FlatNode::VT_INSTANCE_IPS, instance_ips);
  }
  explicit FlatNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FlatNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FlatNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<FlatNode> CreateFlatNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> namespace_ = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Wasm::Common::KeyVal>>> labels = 0,
    flatbuffers::Offset<flatbuffers::String> owner = 0,
    flatbuffers::Offset<flatbuffers::String> workload_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Wasm::Common::KeyVal>>> platform_metadata = 0,
    flatbuffers::Offset<flatbuffers::String> istio_version = 0,
    flatbuffers::Offset<flatbuffers::String> mesh_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> app_containers = 0,
    flatbuffers::Offset<flatbuffers::String> cluster_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> instance_ips = 0) {
  FlatNodeBuilder builder_(_fbb);
  builder_.add_instance_ips(instance_ips);
  builder_.add_cluster_id(cluster_id);
  builder_.add_app_containers(app_containers);
  builder_.add_mesh_id(mesh_id);
  builder_.add_istio_version(istio_version);
  builder_.add_platform_metadata(platform_metadata);
  builder_.add_workload_name(workload_name);
  builder_.add_owner(owner);
  builder_.add_labels(labels);
  builder_.add_namespace_(namespace_);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<FlatNode> CreateFlatNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *namespace_ = nullptr,
    std::vector<flatbuffers::Offset<Wasm::Common::KeyVal>> *labels = nullptr,
    const char *owner = nullptr,
    const char *workload_name = nullptr,
    std::vector<flatbuffers::Offset<Wasm::Common::KeyVal>> *platform_metadata = nullptr,
    const char *istio_version = nullptr,
    const char *mesh_id = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *app_containers = nullptr,
    const char *cluster_id = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *instance_ips = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto namespace___ = namespace_ ? _fbb.CreateString(namespace_) : 0;
  auto labels__ = labels ? _fbb.CreateVectorOfSortedTables<Wasm::Common::KeyVal>(labels) : 0;
  auto owner__ = owner ? _fbb.CreateString(owner) : 0;
  auto workload_name__ = workload_name ? _fbb.CreateString(workload_name) : 0;
  auto platform_metadata__ = platform_metadata ? _fbb.CreateVectorOfSortedTables<Wasm::Common::KeyVal>(platform_metadata) : 0;
  auto istio_version__ = istio_version ? _fbb.CreateString(istio_version) : 0;
  auto mesh_id__ = mesh_id ? _fbb.CreateString(mesh_id) : 0;
  auto app_containers__ = app_containers ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*app_containers) : 0;
  auto cluster_id__ = cluster_id ? _fbb.CreateString(cluster_id) : 0;
  auto instance_ips__ = instance_ips ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*instance_ips) : 0;
  return Wasm::Common::CreateFlatNode(
      _fbb,
      name__,
      namespace___,
      labels__,
      owner__,
      workload_name__,
      platform_metadata__,
      istio_version__,
      mesh_id__,
      app_containers__,
      cluster_id__,
      instance_ips__);
}

inline const Wasm::Common::FlatNode *GetFlatNode(const void *buf) {
  return flatbuffers::GetRoot<Wasm::Common::FlatNode>(buf);
}

inline const Wasm::Common::FlatNode *GetSizePrefixedFlatNode(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Wasm::Common::FlatNode>(buf);
}

inline bool VerifyFlatNodeBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Wasm::Common::FlatNode>(nullptr);
}

inline bool VerifySizePrefixedFlatNodeBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Wasm::Common::FlatNode>(nullptr);
}

inline void FinishFlatNodeBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Wasm::Common::FlatNode> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedFlatNodeBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Wasm::Common::FlatNode> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Common
}  // namespace Wasm

#endif  // FLATBUFFERS_GENERATED_NODEINFO_WASM_COMMON_H_
